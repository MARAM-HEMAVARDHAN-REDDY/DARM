const video5 = document.getElementsByClassName("input_video5")[0], out5 = document.getElementsByClassName("output5")[0], out6 = document.getElementsByClassName("output6")[0], controlsElement5 = document.getElementsByClassName("control5")[0], canvasCtx5 = out5.getContext("2d"), canvasCtx6 = out6.getContext("2d"); let AutoTune_BiasFlag = 0, AutoTune_Status = "----", O_CameraPosition_Status = "----"; const ObsWindowLength = 300, RollQueue = Array(300).fill(0), YawQueue = Array(300).fill(0), PitchQueue = Array(300).fill(0); var O_HeadTurnLeft_Flag, O_HeadTurnRight_Flag, O_HeadTurnDown_Flag, O_HeadTurnUp_Flag, NoLandmarks, Roll_Bias, Yaw_Bias, Pitch_Bias, AutoTune_Instancecount = 0; let Status = "----", roll = 0, pitch = 0, yaw = 0, MPN_LA, MPN_RA, MPN_NA; function calculatemode(a) { let t = {}; a.forEach(a => t[a] = (t[a] || 0) + 1); let e, l = 0; for (let n in t) t[n] > l && (e = n, l = t[n]); return +e } function rollNumber(a, t) { return (a += t) > 179 && (a = -178 + (a - 179) - 1), a < -178 && (a = 179 - (-178 - a) + 1), a } function calculateDistance(a, t) { let e = t.x - a.x, l = t.y - a.y, n = t.z - a.z; return Math.sqrt(e * e + l * l + n * n) } function calculateAngle(a, t, e) { return Math.acos((t * t + e * e - a * a) / (2 * t * e)) * (180 / Math.PI) } function zColor(a) { let t = clamp(a.from.z + .5, 0, 1); return `rgba(0, ${255 * t}, ${255 * (1 - t)}, 1)` } function drawLine(a, t, e, l, n, o = "black", s = 3) { a.beginPath(), a.moveTo(t, e), a.lineTo(l, n), a.strokeStyle = o, a.lineWidth = s, a.stroke() } function onResultsPose(a) { if (canvasCtx6.save(), canvasCtx6.clearRect(0, 0, out6.width, out6.height), canvasCtx5.save(), canvasCtx5.clearRect(0, 0, out5.width, out5.height), canvasCtx5.drawImage(a.image, 0, 0, out5.width, out5.height), a.poseLandmarks) { landmarks = a.poseLandmarks; let t = landmarks[0], e = landmarks[8], l = landmarks[7], n = calculateDistance(e, t), o = calculateDistance(l, t), s = calculateDistance(e, l), i = [n, o, s], c = calculateAngle(i[0], i[1], i[2]), r = calculateAngle(i[1], i[2], i[0]), u = calculateAngle(i[2], i[0], i[1]); MPN_LA = r, MPN_RA = c, MPN_NA = u, console.log("difference : ", Math.abs(r - c)), console.log("Leftangle :", r), console.log("Rightangle :", c), console.log("Noseangle :", u), canvasCtx6.fillStyle = "Red", canvasCtx6.font = "bold 15px Arial", canvasCtx6.fillText(`Difference : ${Math.abs(r - c)}`, 15, 250), canvasCtx6.fillText(`Leftangle : ${r}`, 15, 265), canvasCtx6.fillText(`Rightangle : ${c}`, 15, 280), canvasCtx6.fillText(`Noseangle : ${u}`, 15, 295), NoLandmarks && Math.abs(r - c) >= 30 && (LRB = MPN_LA > MPN_RA, Status = (RLB = MPN_RA > MPN_LA) ? "HEAD_RIGHT_TURN_POSE" : LRB ? "HEAD_LEFT_TURN_POSE" : "----", canvasCtx6.fillStyle = "red", canvasCtx6.font = "bold 15px Arial", canvasCtx6.fillText(Status, 15, 90)), drawConnectors(canvasCtx5, a.poseLandmarks, POSE_CONNECTIONS, { color(a) { let t = out5.width * a.from.x, e = out5.height * a.from.y, l = out5.width * a.to.x, n = out5.height * a.to.y, o = clamp(a.from.z + .5, 0, 1), s = clamp(a.to.z + .5, 0, 1), i = canvasCtx5.createLinearGradient(t, e, l, n); return i.addColorStop(0, `rgba(0, ${255 * o}, ${255 * (1 - o)}, 1)`), i.addColorStop(1, `rgba(0, ${255 * s}, ${255 * (1 - s)}, 1)`), i } }), drawLandmarks(canvasCtx5, Object.values(POSE_LANDMARKS_LEFT).map(t => a.poseLandmarks[t]), { color: zColor, fillColor: "#000000" }), drawLandmarks(canvasCtx5, Object.values(POSE_LANDMARKS_RIGHT).map(t => a.poseLandmarks[t]), { color: zColor, fillColor: "#000000" }), drawLandmarks(canvasCtx5, Object.values(POSE_LANDMARKS_NEUTRAL).map(t => a.poseLandmarks[t]), { color: zColor, fillColor: "#000000" }) } canvasCtx6.restore(), canvasCtx5.restore() } function onResultsFaceMesh(a) { O_HeadTurnLeft_Flag = 0, O_HeadTurnRight_Flag = 0, O_HeadTurnDown_Flag = 0, O_HeadTurnUp_Flag = 0; var t, e, l, n = [], o = [1, 33, 263, 61, 291, 199]; canvasCtx5.save(), canvasCtx5.clearRect(0, 0, controlsElement5.width, controlsElement5.height); var s = a.image.width, i = a.image.height, c = 1.28 * i, r = cv.matFromArray(3, 3, cv.CV_64FC1, [c, 0, s / 2, 0, c, i / 2, 0, 0, 1]), u = cv.matFromArray(4, 1, cv.CV_64FC1, [.1318020374, -.1550007612, -.0071350401, -.0096747708]); if (a.multiFaceLandmarks) { for (let $ of a.multiFaceLandmarks) for (let _ of (drawConnectors(canvasCtx5, $, FACEMESH_TESSELATION, { color: "#C0C0C070", lineWidth: 1 }), o)) { var d = $[_], t = d.x * s, e = d.y * i; n.push(t), n.push(e) } if (n.length > 0) { var C = new cv.Mat, x = new cv.Mat; let h = o.length, f = cv.matFromArray(h, 2, cv.CV_64FC1, n); var m = cv.matFromArray(6, 3, cv.CV_64FC1, [0, -1.126865, 7.475604, -4.445859, 2.663991, 3.173422, 4.445859, 2.663991, 3.173422, -2.456206, -4.342621, 4.283884, 2.456206, -4.342621, 4.283884, 0, -9.403378, 4.264492]); if (cv.solvePnP(m, f, r, u, C, x, !1, cv.SOLVEPNP_ITERATIVE)) { var v = cv.Mat.zeros(3, 3, cv.CV_64FC1); let g = new cv.Mat; cv.Rodrigues(C, v, g); var T = Math.sqrt(v.data64F[0] * v.data64F[0] + v.data64F[3] * v.data64F[3]); if (T < 1e-6 ? (t = Math.atan2(-v.data64F[5], v.data64F[4]), e = Math.atan2(-v.data64F[6], T), l = 0) : (t = Math.atan2(v.data64F[7], v.data64F[8]), e = Math.atan2(-v.data64F[6], T), l = Math.atan2(v.data64F[3], v.data64F[0])), roll = Number((180 * (e / Math.PI)).toFixed(2)), pitch = Number((180 * (t / Math.PI)).toFixed(2)), yaw = Number((180 * (l / Math.PI)).toFixed(2)), AutoTune_Instancecount < 300 && (RollQueue.shift(), RollQueue.push(Math.round(roll)), YawQueue.shift(), YawQueue.push(Math.round(yaw)), PitchQueue.shift(), PitchQueue.push(Math.round(pitch)), AutoTune_Instancecount++), 300 == AutoTune_Instancecount && (AutoTune_BiasFlag = 1, Roll_Bias = calculatemode(RollQueue), Yaw_Bias = calculatemode(YawQueue), Pitch_Bias = calculatemode(PitchQueue), canvasCtx6.fillStyle = "Red", canvasCtx6.font = "bold 15px Arial", canvasCtx6.fillText(`Roll_Bias : ${Roll_Bias}`, 15, 125), canvasCtx6.fillText(`Pitch_Bias : ${Pitch_Bias}`, 15, 145), canvasCtx6.fillText(`Yaw_Bias : ${Yaw_Bias}`, 15, 160), Roll_Bias < 30 && Roll_Bias > -30 ? (O_CameraPosition_Status = "Optimal", canvasCtx6.fillText("Cam Position : Optimal", 15, 175)) : (O_CameraPosition_Status = "Non Optimal", canvasCtx6.fillText("Cam Position : Non Optimal", 15, 175))), AutoTune_Status = 1 == AutoTune_BiasFlag ? "Auto Tuning Complete" : "Auto Tuning In Progress", roll > 65 || roll < -65) NoLandmarks = 1; else { if (NoLandmarks = 0, AutoTune_BiasFlag) { var p = Roll_Bias + 35, F = Roll_Bias - 35, A = rollNumber(Pitch_Bias, 30), P = rollNumber(Pitch_Bias, -25); canvasCtx6.fillText(`P_HEAD_DOWN_Th : ${A} /-155`, 15, 190), canvasCtx6.fillText(`P_HEAD_UP_Th : ${P} / 145`, 15, 205), canvasCtx6.fillText(`P_HEAD_LEFT_Th : ${F}`, 15, 220), canvasCtx6.fillText(`P_HEAD_RIGHT_Th : ${p}`, 15, 235), pitch > 0 && pitch < 145 ? (O_HeadTurnUp_Flag = 1, Status = "HEAD_UP") : pitch < 0 && pitch > -155 ? (O_HeadTurnDown_Flag = 1, Status = "HEAD_DOWN") : roll > p && yaw < 45 && yaw > -45 ? (O_HeadTurnRight_Flag = 1, Status = "HEAD_RIGHT_TURN") : roll < F && yaw < 45 && yaw > -45 ? (O_HeadTurnLeft_Flag = 1, Status = "HEAD_LEFT_TURN") : Status = "----" } canvasCtx6.fillText(Status, 15, 90) } canvasCtx6.fillStyle = "red", canvasCtx6.font = "bold 15px Arial", canvasCtx6.fillText(`roll: ${roll}`, 15, 30), canvasCtx6.fillText(`pitch : ${pitch}`, 15, 50), canvasCtx6.fillText(`yaw : ${yaw}`, 15, 70) } } canvasCtx6.fillStyle = "red", canvasCtx6.font = "bold 15px Arial", C.delete(), x.delete() } else NoLandmarks = 1; canvasCtx6.restore(), canvasCtx5.restore() } const faceMesh = new FaceMesh({ locateFile: a => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.1/${a}` }); faceMesh.onResults(onResultsFaceMesh); const pose = new Pose({ locateFile: a => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.2/${a}` }); pose.onResults(onResultsPose); const camera = new Camera(video5, { async onFrame() { await pose.send({ image: video5 }), await faceMesh.send({ image: video5 }) }, width: 480, height: 480 }); camera.start();